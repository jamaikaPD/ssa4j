#summary A quick start guide that demonstrates how to use SSA4J annotations

<wiki:toc max_depth="3" />

= Introduction =
This tutorial assumes that you already have a working knowledge of the core concepts of [http://community.screen-scraper.com/documentation screen-scraper].  It expands on [http://community.screen-scraper.com/Tutorial_4_Page_1 Tutorial 4: Scraping an E-commerce Site from External Programs] to demonstrate how SSA4J is used to create an API that is easier to use and more consistent with Java.

== Scraping From an External Java Program the "Old Way"  ==

Before proceeding it would be a good idea to go through [http://community.screen-scraper.com/Tutorial_2_page_1 Tutorial 2], if you haven't done so already.

*NOTE* If you haven't gone through [http://community.screen-scraper.com/Tutorial_2_page_1 Tutorial 2], or don't still have the scraping session you created in it, you can download it [http://community.screen-scraper.com/files/Shopping%20Site%20(Scraping%20Session).sss here] and [http://community.screen-scraper.com/importing_and_exporting_objects import] it into screen-scraper. 

... ok, now let's review how we [http://community.screen-scraper.com/invoking_screen-scraper_from_Java Invoking screen-scraper from Java] in a world without SSA4J.

{{{
// Generate a RemoteScrapingSession object, which 
// acts as the driver, or interface, to screen-scraper.
RemoteScrapingSession remoteScrapingSession = new RemoteScrapingSession("Shopping Site");

// Set the variables.
// Remember that these two top variables correspond to the POST
// parameters we use for the "Login" scrapeable file.
remoteScrapingSession.setVariable( "EMAIL_ADDRESS", "test@test.com" );
remoteScrapingSession.setVariable( "PASSWORD", "testing" );

// screen-scraper will use this parameter to search the products.
remoteScrapingSession.setVariable("SEARCH","dvd");

// We start screen-scraper at page 1 of the search results.
// Note that we could have also done this in an "initialize" 
// script within screen-scraper, which is common.
remoteScrapingSession.setVariable( "PAGE", "1" );

// Tell the session to scrape. This method call might take
// a little while since it will need to wait for screen-scraper
// to fully extract the data before it returns.
remoteScrapingSession.scrape();

// Get the data set that was stored by screen-scraper in a
// session variable. This data set corresponds to the "PRODUCTS"
// extractor pattern found under the "Details page" scrapeable
// file.
DataSet products = ( DataSet )remoteScrapingSession.getVariable( "PRODUCTS" );

// Iterate through each of the data records screen-scraper
// extracted, outputting each of them to the browser.
for( int i = 0; i < products.getNumDataRecords(); i++ )
{
    DataRecord product = products.getDataRecord( i );
    System.out.println( "==============" );
    System.out.println( "Product #" + i );
    System.out.println( "Title: " + product.get( "TITLE" ) );
    System.out.println( "Model: " + product.get( "MODEL" ) );
    System.out.println( "Shipping Weight: " + product.get( "SHIPPING_WEIGHT" ) );
    System.out.println( "Manufactured By: " + product.get( "MANUFACTURED_BY" ) );
    System.out.println( "==============" );
}

// Be sure to disconnect from the server.
remoteScrapingSession.disconnect();

}}}

== Why the Old Way is "Bad" ==
To be honest, the above code isn't all that bad.   That said, there are some drawbacks that make creating a formal API around a `RemoteScrapingSession` extremely tedious.  

Below is a good example of all that you would have to do to create a Java API around `RemoteScrapingSession` for the example above ...

{{{
// This is a subclass of RemoteScrapingSession that abstracts the caller
// from having to know anything about the underlying RemoteScrapingSession
// and exposes a "typed" interface for setting session variables and 
// retrieving product content that was scraped from the site.
public class ShoppingSiteScrapingSession extends RemoteScrapingSession {
    
    // This is a simple constructor that hides the string literal "Shopping Site"
    // from the caller.  This is useful in the event that this string changes
    // later during development it won't impact anyone creating this class.
    public ShoppingSiteScrapingSession() 
      throws UnknownHostException, RemoteScrapingSessionException, IOException
    {
        super("Shopping Site");
    }
  
    // Now we create a setter method for every session variable that we want
    // the caller to provide.  For each, we call this.setVariable(..)
    // with the String literal required for each session variable.  
    public void setEmailAddress(String emailAddress) throws RemoteScrapingSessionException {
        this.setVariable( "EMAIL_ADDRESS", emailAddress );
    }
    public void setPassword(String password) throws RemoteScrapingSessionException {
        this.setVariable( "PASSWORD",  password );
    }
    public void setSearchKeyWord(String searchKeyWord) throws RemoteScrapingSessionException {
        this.setVariable("SEARCH", searchKeyWord );
    }
    public void setPage(int page) throws RemoteScrapingSessionException {
        this.setVariable( "PAGE", Integer.toString(page));
    }
    
    // Because we don't want to expose the raw the DataSet to the caller, we create
    // a method that converts the DataSet into an array of Product objects
    public Product[] getProducts() throws RemoteScrapingSessionException {
        DataSet dset = ( DataSet )this.getVariable( "PRODUCTS" );
        Product[] products = new Product[dset.getNumDataRecords()];
        for( int i = 0; i < products.length; i++ )
        {
            DataRecord rec = dset.getDataRecord( i );
            products[i] = new Product(rec);
        }
        return products;
    }
}
}}}

{{{
// This is a wrapper around DataRecord that abstracts the caller
// from having to know anything about the underlying DataRecord.
public class Product {

    private DataRecord rec;
    
    public Product(DataRecord rec) {
        this.rec = rec;
    }

    public String getTitle() {
        return (String) rec.get( "TITLE" );
    }
    
    public String getModel() {
        return (String) rec.get( "MODEL" );
    }
    
    public String getWeight() {
        return (String) rec.get( "SHIPPING_WEIGHT" );
    }
    
    public String getManufacturer() {
        return (String) rec.get( "MANUFACTURED_BY" );
    }
}
}}}

Assuming we have the Java API as shown above, using it is pretty clean ...

{{{
ShoppingSiteScrapingSession session = new ShoppingSiteScrapingSession();
session.setEmailAddress("test@test.com");
session.setPassword("testing");
session.setSearchKeyWord("dvd");
session.setPage(1);

session.scrape();

for(Product product : session.getProducts())
{
    System.out.println( "==============" );
    System.out.println( "Title: " + product.getTitle() );
    System.out.println( "Model: " + product.getModel() );
    System.out.println( "Shipping Weight: " + product.getWeight() );
    System.out.println( "Manufactured By: " + product.getManufacturer() );
    System.out.println( "==============" );
}
}}}

Unfortunately when we now want to interact with the DataSets that are returned from the scrape (e.g. products) we are once again faced with having to know all the necessary String literals and not having a clean Java Class that encapsulates the !DataSet.

To deal with this, you would need to add a new method that converts the raw DataSet into an Array of Product objects.  The method could look something like this:

{{{
public Product[] getProducts() throws RemoteScrapingSessionException {
    // pull the DataSet from the scraping session using the "PRODUCT" 
    // string literal 
    DataSet dset = ( DataSet )this.getVariable( "PRODUCTS" );
    
    // Create a Product[] large enough to hold all the records
    Product[] products = new Product[dset.getNumDataRecords()];
    
    // Iterate over all the records, for each create a Product wrapper around the DataRecord
    for( int i = 0; i < products.length; i++ )
    {
        DataRecord rec = dset.getDataRecord( i );
        products[i] = new Product(rec);
    }
    return products;
}
}}}

If you want to hide the `DataSet` interactions and instead return an Array of `Product` Objects you might create a `Product` class that takes a `DataRecord` object as a constructor object and during creation, extracts all the relevant fields from the `DataRecord` into the `Product` instance.

{{{
public class Product {

    public Product(DataRecord rec) {
        this.title = rec.get( "TITLE" );
        this.model = rec.get( "MODEL" );
        this.weight = rec.get( "SHIPPING_WEIGHT" );
        this.manufacturer = rec.get( "MANUFACTURED_BY" );
    }

    public String title;
    
    public String model;
    
    public Float weight;
    
    public String manufacturer;

}
}}}


 

= Create a Java API for the Shopping Site using SSA4J in 3 Simple Steps =
The process of creating a proper Java API for a scrape session using SSA4J can be accomplished with 2 easy steps:

  # Create and Annotate a Class for your !ScrapeSession
  # Create and Annotate a Class for each !DataRecord you expect to find in a session's !DataSet


If we wanted to create a proper API for the scrape session described above we would likely want to create a Class called `ShoppingSiteScrapingSession` that contained explicit getters and setters for each of the session variables (e.g. setEmailAddress(), setPassword(), etc.).

== Step 1. Create and Annotate A Class to Represent the Shopping Site Scrape Session ==

To begin, lets start by creating a class that clearly declares all the session variables that are required.

{{{
public class ShoppingSiteScrapingSession {
  private String emailAddress;
  private String password;
  private String search;
  private int page;
    
  // getters and setters here ... 
}
}}}

Annotate the using the @!ScrapeSession annotation.  Notice that the `name` field on the annotation is set to `"Shopping Site"`.

{{{
@ScrapeSession(name="Shopping Site")
public class ShoppingSiteScrapingSession {
...
}
}}}